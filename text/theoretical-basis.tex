\newpage
\chapter{Theoretical Basis}
In the first section, this chapter describes the anatomy of a URL and how resources are searched and filtered using URL parameters. The second section illustrates the concept of site searching. Furthermore, filters and facets are depicted within the scope of this thesis. The fourth section covers the definition of a browser extension along with its architecture. Finally, the framework for the extension's UI implementation is outlined.


% Uniform Resource Locator
\section{URL}
Uniform Resource Locator, or URL, is a compact string representation for a resource available via the Internet \autocite{berners1994uniform}. By offering a general identification of the resource's location, URLs are used to locate resources. These resources could be an image, a CSS file, an HTML page, etc. In practice, there are a few exceptions, the most frequent of which is a URL leading to a resource that has either relocated or vanished. After locating a resource, a system may carry out a number of actions on it, which can be described by phrases like \emph{access}, \emph{update}, \emph{replace}, and \emph{find attributes}. For each URL scheme, only the \emph{access} method needs to be supplied. The scheme of the URL will be discussed further. Here is an example of an HTTPS URL: \url{https://example.com/filtre/popup.html}.

Uniform Resource Identifier, or URI, is a string of characters that, like the URL, identifies a resource on the internet by location, name, or both. It makes it possible to identify resources consistently. Since URI is the superset of URL, every URL is also a URI, but some URIs are not URLs.

\subsection{Anatomy of a URL}
\label{url_anatomy}
A URL is made up of various components, some of which are required and others are optional \autocite{mozilla2022url}. The most important parts are provided in the following sections:

\subsection*{Scheme}
The scheme is the first component of the URL, and it specifies the protocol that the browser has to use to make a request for the resource. In a computer network, a protocol is a predetermined procedure for data exchange or transfer. The most common protocol is HTTP which stands for Hypertext Transfer Protocol. Nowadays most websites use HTTPS protocol which stands for Hypertext Transfer Protocol Secure.

\subsection*{Authority}
Character pattern ("://") separates the authority from the scheme. If the authority is available, the host and port are also included, with a colon in between:

\begin{itemize}
  \item The host holding the resource is identified by its hostname. Either a domain name or an IP address can be used as the hostname. Although hosts and servers do not correspond one to one, a server offers services in the host's name.
  \item The technical gateway used to access the resources of the web server is indicated by the port number. It is typically excluded if the web server allows users to access its resources using the standard ports for the HTTP protocol. If not, it is necessary.
\end{itemize}

\subsection*{Path}
The web client's desired access point is identified by the path as a specific resource on the host. The path component contains data, usually organized in hierarchical form, that, along with data in the non-hierarchical query component, serves to identify a resource within the scope of the URI's scheme and naming authority \autocite{berners2005uniform}. The first question mark ("?") or number sign ("\#"), or the last URI character, marks the end of the path. A path is made up of a series of path segments that are divided by the slash ("/") character. For every URI, a path is defined, even though the path may be empty. Only when a URI will serve as the context for relative references must the slash character be used to denote hierarchy. For example, \url{https://example.com/filtre/dist/popup.html} has a path of \texttt{/filtre/dist/popup.html}, whereas the path to this URI \texttt{<foo://example.com?popup>} is empty.

\subsection*{Query String}
The query component contains non-hierarchical data that, along with data in the path component, serves to identify a resource within the scope of the URI's scheme and naming authority \autocite{berners2005uniform}. The first question mark ("?") character designates the start of the query component, and the number sign ("\#") or the URI's final character designates its end.

A query is commonly found in the URL of dynamic pages. and is represented by a question mark followed by one or more parameters. The query directly follows the hostname, path, or port number. For example, this URL was generated by Google when searching for the word \emph{query}:

\begin{center}
  \url{https://www.google.com/search?q=query&rlz=1C5GCEM_enDE993DE993&oq=query&aqs=chrome..69i57j0i512l4j69i60l3.938j0j7&sourceid=chrome&ie=UTF-8}
\end{center}

\noindent This is the query part:

\begin{center}
  \url{?q=query&rlz=1C5GCEM_enDE993DE993&oq=query&aqs=chrome..69i57j0i512l4j69i60l3.938j0j7&sourceid=chrome&ie=UTF-8}
\end{center}

It is sometimes preferable to forgo percent-encoding those characters for usability reasons because query components are regularly used to store identifying information as key-value pairs, with a reference to another URI being one commonly used value.

\subsection*{Anchor}
An anchor is a type of bookmark within the resource that instructs the browser to display the content located at that bookmarked location. For instance, the browser will scroll to the point where the anchor is set in an HTML document; in a video or audio document, the browser will try to find the time the anchor denotes. It is important to note that the part following the ("\#") character is never included in the request sent to the server.

\subsection{Search and Filter URL Parameters}
Search and filter URL parameters are parameters or query strings that add information to a specific URL. A search or filter parameter facilitates the search for a specific phrase or keyword within search engine results. They include what is requested while excluding irrelevant content. Aside from the functions mentioned above, the most common use cases for parameters are tracking, pagination, site search, sorting, and filtering.


%Site Search
\section{Site Search}
Providing a search function that searches your Web pages is a design strategy that offers users a way to find content \autocite{w3c2016search}. Without having to comprehend or navigate the site's structure, users can find content by searching for particular words or phrases. On large websites, this may be a quicker or simpler method of finding content. A great site search function is specific to the website and not only constantly indexes the site to make sure that access to the most recent content is simple, but it also directs users as they navigate a website's page, assisting them in discovering new and interesting content. The best site search tools draw users by making it easy for them to find the information they need immediately and by compiling helpful data on the site's engaging products and articles.


%Filters
\section{Filters and Facets}
\label{filters_and_facets}
Filtering refers to the process of limiting a search based on predefined categories. These categories are frequently broad and based on a single dimension of the product. This allows users to quickly narrow down a great number of products to a smaller group for further search.

Filters are broad categories set forth by the business that remains constant across searches and are frequently applied in the background. Nielsen Norman Group\footnote{Nielsen Norman Group is a pioneer in the field of user experience. NN/g carries out ground-breaking research, educates and accredits UX professionals, and offers clients UX consulting. More information on \url{https://www.nngroup.com/}} defines filters as one such tool, which analyzes a given set of content to exclude items that don't meet certain criteria \autocite{whitenton2014filters}. For instance, a book retailer online might use the genre filter, with the four categories of fiction, non-fiction, romance, and thriller as options. The genre filter is activated and only displays fiction books on the results page when a website visitor clicks on fiction in the top navigation.

Facets, also known as facet filters, enable users to filter results by selecting values along different dimensions or facets \autocite{qu2021study}. It is widely used in e-commerce search engines and digital libraries where documents have rich metadata. Broad, universal filters do not allow for finding products and results in a specific, targeted manner. Faceted search is a more granular method that does.

The distinction between filters and facets is essentially one of degree, but it is a significant one. The ideal faceted navigation should offer numerous filters, one for each distinctive aspect of the content. In contrast to systems that only offer one or two types of filters, faceted navigation is, therefore, more adaptable and practical, especially for huge content sets. In addition to giving users a structure to help them understand the content space and provide them with suggestions on what is available and how to look for it, faceted navigation also offers a description of various aspects of the content.

A well-designed user interface includes filters and facets. By guiding the user to the best result quickly, contextual factors that differ depending on the product or category encourage a user-friendly experience. Despite the fact that faceted navigation systems have clear advantages for users, it is substantially more expensive to design and maintain because each facet requires different metadata to be applied to both current and future content. By giving users more options to comprehend and manipulate, the additional power of faceted navigation increases interaction costs. Often, a straightforward filter is simpler to understand and apply.


%Browser Extension
\section{Browser Extension}
Browser extensions or add-ons are third-party programs that can extend the functionality of browsers and improve users' browsing experience \autocite{some2019empoweb}. A browser extension, as opposed to a standard web page, is created specifically for a given browser and uses that browser's extension API. It was necessary to choose a browser as a result. Some frameworks try to make it feasible to create an extension for several different browsers at once. Although the caliber of these frameworks was unclear, it was decided that the expense of potential problems and additional time spent debugging in many browsers outweighed the benefits.

%Chrome Extension Architecture
\subsection{Chrome Extension Architecture}
Extensions are built on web technologies such as HTML, JavaScript, and CSS. They run in a separate, sandboxed execution environment and interact with the Chrome browser \autocite{google2021what}. They also have access to the APIs that browsers provide for tasks like XMLHttpRequests and HTML5 features on websites. The following files can be found in an extension:

\begin{itemize}
  \item A \texttt{manifest.json} file
  \item One or more HTML files
  \item Any other files such as CSS or JavaScript needed by the extension to run
\end{itemize}

The majority of extensions have a background page that contains their primary logic and state. They frequently also contain content scripts that can communicate with websites. Asynchronous message passing is used to communicate between the background page and the content scripts. Additionally, extensions can save data via \texttt{localStorage} and other HTML5 storage APIs.

\subsection{Manifest Files}
A \texttt{manifest.json} file is required for each extension. It includes crucial information about the extension, such as its name, version, scripts used for its content, minimum Chrome version, and permissions. The content scripts field was the most crucial one for an extension. There should be a separate content script for each study and content-related web page. Every single one is specified in the scripts column, which also mapped each one to the appropriate URLs.

\subsection{Content Scripts}
Content scripts are JavaScript files that are used on websites to add new functionality. They have full control to modify the entire web page because they can directly access the DOM of these websites. The content script is injected into a tab when the web page is loaded, and runs in the same process space of the renderer of the web tab and can thus access its DOM objects. Injected content scripts in a tab can only communicate with the extension core via Chrome's IPC \autocite{liu2012chrome}.

\subsection{Service Worker}
\label{service_worker}
In Manifest V3, the Chrome extension platform shifts from using background pages to using service workers. A service worker is a script that your browser runs in the background, distinct from a web page, opening the door to features that don't need a web page or user input \autocite{chrome2021service}. With the aid of this technology, users can enjoy native-like features on the open web, such as push notifications, robust offline support, background synchronization, and many others. Service providers drew some of their inspiration from the background pages in Chrome Extensions, but improvements were added for the web.

Service workers are specialized JavaScript assets that act as proxies between web browsers and web servers. They aim to improve reliability by providing offline access, as well as boost page performance \autocite{chrome2021service}. Websites are gradually improved by service workers through a lifetime akin to that of platform-specific programs.


%React
\section{React}
\label{react}
React is a product of Facebook's engineering team, which is a JavaScript framework for creating user interfaces \autocite{gackenheimer2015introducing}. Because of its simplicity and straightforward but efficient development process, React is quite well-liked in the developer communities. Interactive user interfaces are simpler to develop with React. It effectively updates by accurately drawing each state's view's constituent parts, and it updates the application's data \autocite{islam2017reactjs}.

React's primary goal is to deliver the best rendering performance. Its strength stems from the attention paid to individual elements. Rich UI designs are found to be simple for developers to create when using reusable components. React incorporates the View part from the MVC model \autocite{maratkar2021re}. One-way data flow\footnote{Data flows in one direction, from parent to child.} is implemented in React to make it simpler than conventional data binding. React uses a virtual DOM to provide programming that is less complex and executes more quickly. It makes use of composition to create intricate user interfaces out of simple building blocks known as Components \autocite{david2020building}.

\subsection{Component and Props}
Components are self-contained and reusable pieces of code. They perform the same function as JavaScript functions, but they operate independently and return React elements that describe what ought to be displayed on the screen. They are classified as Class components or Function components. To describe what should be rendered, JSX, a combination of HTML and JavaScript, is used. See \autoref{jsx} for a more in-depth explanation. These functions accept arbitrary inputs, called \texttt{props}, and store property values inside a \texttt{state} object.

Immutable data supplied into a component during development is known as \texttt{props} or properties. Because a component can function and seem different depending on the properties supplied to it, \texttt{props} enable React components to be flexible and reusable.

Using props, data moves down the component tree in React. Callback functions are supplied as \texttt{props} so that a child component can communicate with its parent. Callback methods and other data must be passed down numerous layers in large React apps due to the component tree's depth. \emph{Prop-drilling}\footnote{\emph{Prop-drilling} is the unofficial term for the process of delivering data to a deeply nested component by passing it through a number of nested children components.} is a technique that results in tightly connected components and a less maintainable program. This is one of the reasons why complex React apps require architectural patterns.

\subsection{State and Lifecycle}
The state allows an application to manage data change. It is defined as an object in which key-value pairs specify various data that should be tracked in the application. The \texttt{state} is optional; components without a state are referred to as presentational components. Components with a state are referred to as stateful components.

The built-in functions known as lifecycle methods are called whenever a state or prop changes, before rendering or after rendering a component, a component is destroyed, or both.

\subsection{Class-based components}
By extending the \texttt{React.Component} class, a class-based Component can be produced. The class-based component's state is modified via the \texttt{setState()} method and retrieved via the \texttt{this.state} property. Using \texttt{setState()} function causes the component to be re-rendered, which is not the case when directly modifying the state. Class-based components include lifecycle methods that can be used to create behavior with a higher degree of complexity. In addition, a render method is required to return JSX elements.


\subsection{Function components}
The term function component refers to a pure function that takes \texttt{props} as input and outputs a JSX element. React Hooks are used to give the function component the same access to state and lifecycle methods as class-based components. For more information on what React Hooks are and how they work, refer to \autoref{react_hooks}. In comparison to class-based components, using function components with hooks might make React applications smaller and more manageable. There are a couple of reasons why function components are preferable \autocite{phan2020react}:

\begin{itemize}
  \item Since function components lack state and lifecycle-hook, development time is reduced, readability is improved, testing and debugging are simplified, and components can be reused. A function component is a straightforward JavaScript function.
  \item As the compilation time for function components is shorter than that of class components, performance will increase.
  \item Utilizing a function component eliminates the need to plan for the component's separation into a container and a regular UI component.
\end{itemize}

\subsection{React Hooks}
\label{react_hooks}
React Hooks allow the same functionality found in Stateful Components to be used in Functional Components, making them ideal for more complex functional components. As opposed to using classes, React's state and lifecycle functions can be accessed through the use of "hooks", which are essentially functions that allow the management of the logic within a component into reusable, isolated units. There is no state in a function component by default, but it is possible to maintain it with the help of the \texttt{useState} React hook. There is no restriction on the number of times any hook, including \texttt{useState}, can be used within the same component. In most cases, the word "use" will be the first part of a hook's name. The importance of adhering to naming conventions remains even though React does not enforce them.

Though function components lack native support for lifecycle methods, these can be implemented with the \texttt{useEffect} hook. The \texttt{useEffect} hook will automatically trigger a function to be executed whenever the component is re-rendered; however, this behavior can be modified to execute only when certain conditions are met.

The \texttt{useContext} hook, which will be described in \autoref{contextApi}, is another React hook. In addition to built-in hooks, custom hooks can be made, allowing functionality to be reused throughout components.

\subsection{Virtual DOM}
React creates a new View for each component in the application based on their immutable states and props, and any changes to the states or props trigger a re-rendering of the View. As a result, the Views can be anticipated and even tested. Re-rendering views by replacing the DOM with a new version is a time-consuming process that can negatively affect the user experience because it results in the loss of the user's scroll position and input data. Using a Virtual DOM, React provides a solution for this \autocite{david2020building}.

By creating a new virtual DOM subtree whenever data in the application changes and comparing it to the previous subtree, views that need updating are redisplayed efficiently without causing other DOM nodes to break. To bring the virtual and actual DOMs into sync, React calculates how few DOM modifications are required. Once queued, the JavaScript DOM manipulations can be executed in bulk rather than one at a time, saving valuable processing time. To achieve the various states, developers use JSX to specify how components should be rendered, and React takes care of the corresponding DOM manipulation.

\subsection{Context API}
\label{contextApi}
By utilizing the Context API, data can be passed around between React components without resorting to the tedious practice of prop-drilling. Multiple components in the component tree can share the same \texttt{Context} object created with the \texttt{createContext} method of the React library. Every \texttt{Context} object comes with a \texttt{Provider} React component that allows consuming components to subscribe to context changes \autocite{react2021context}. When React renders a component that subscribes to this \texttt{Context} object, it will use the closest matching \texttt{Provider} above it in the tree to read the current context value. Data is added to the \texttt{Context} object and made available to its dependent components using a \texttt{Provider}. The \texttt{Provider}, which has a single property named value and accepts variables, functions, or objects as values, defines the \texttt{Context}'s data.

By placing child components inside the \texttt{Provider} component, the \texttt{Context} data can be accessed from any of them via a \texttt{Consumer} that is also present on the \texttt{Context} instance. A \texttt{Consumer} is a React component that subscribes to context changes \autocite{react2021context}. The application uses a variety of contexts for various purposes rather than being restricted to a single instance.

By inheriting its parent's callback function, a child component can modify the parent's state using the Context API. According to the official documentation, \texttt{Context} is used to exchange data that is considered global for the React component tree, such as the current user's authentication status, the current application's color scheme, or the user's preferred language. Using context can limit the reusability of components if they need data provided by another part of the system. Data for a functional component wrapped in a \texttt{Context.Provider} can be accessed via the \texttt{useContext} hook, which acts as the \texttt{Consumer}.

\subsection{JSX}
\label{jsx}
A React extension called JSX makes it simple for web designers to change the DOM using straightforward HTML-style code. Additionally, as all current web browsers are supported by React JS, JSX is interoperable with any browser platform.

Most people find it helpful as a visual aid when working with UI inside the JavaScript code. It also allows React to show more useful error and warning messages \autocite{react2020introducing}. Among the benefits of JSX is the fact that it simplifies and accelerates the template-writing process for HTML-savvy users. Performance improves when code is compiled into JavaScript \autocite{phan2020react}.

