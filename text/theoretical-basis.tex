\newpage
\chapter{Theoretical Basis}
In the first section, this chapter describes the anatomy of a URL and how resources are searched and filtered using URL parameters. The second section illustrates the concept of a site searching. Furthermore, filters and facets are decpicted within the scope of this thesis. The fourth section covers the definition of a browser extension along with its architecture. Finally, the framework for the extension's UI implementation is outlined.

% Uniform Resource Locator
\section{URL}
Uniform Resource Locator, or URL, is a compact string representation for a resource available via the Internet \autocite{berners1994uniform}. URLs are used to "locate" resources, by providing an abstract identification of the resource location. These resources could be an image, a CSS file, an HTML page, etc. In practice, there are a few exceptions, the most frequent of which is a URL leading to a resource that has either relocated or vanished. After locating a resource, a system may carry out a number of actions on it, which can be described by phrases like "access", "update", "replace", and "find attributes". For each URL scheme, only the "access" method needs to be supplied. Here is an example of an HTTP URL: \texttt{http://www.example.com/software/index.html}

\subsection{Anatomy of a URL}
\label{url_anatomy}
A URL is made up of various components, some of which are required and others which are not \autocite{mozilla2022url}. The most important parts are provided in the following sections:

\subsection*{Scheme}
The scheme, which indicates the protocol that the browser must use to request the resource, is the first part of the URL. A protocol is a set method for exchanging or transferring data around a computer network. The most common protocol is HTTP which stands for Hypertext Transfer Protocol. Nowadays most websites use HTTPS protocol which stands for Hypertext Transfer Protocol Secure.

\subsection*{Authority}
The authority is then separated from the scheme by the character pattern \texttt{://}. If the authority is present, it includes both the host (e.g., \texttt{www.example.com}) and the port (80), separated by a colon:

\begin{itemize}
  \item The host name identifies the host that holds the resource. A server provides services in the name of the host, but hosts and servers do not have a one-to-one mapping.
  \item The port number denotes the technical "gateway" used to access the web server's resources. It is typically omitted if the web server grants access to its resources via the HTTP protocol's standard ports. Otherwise, it is required.
\end{itemize}

\subsection*{Path}
The path identifies the specific resource in the host that the web client wants to access. The path component contains data, usually organized in hierarchical form, that, along with data in the non-hierarchical query component, serves to identify a resource within the scope of the URI's scheme and naming authority (if any).  The path is terminated by the first question mark ("?") or number sign ("\#") character, or by the end of the URI \autocite{berners2005uniform}. A path consists of a sequence of path segments separated by a slash ("/") character.  A path is always defined for a URI, though the defined path may be empty.  Use of the slash character to indicate hierarchy is only required when a URI will be used as the context for relative references.  For example, \texttt{http://www.example.com/software/htp/cics/index.html} has a path of \texttt{/software/htp/cics/index.html}, whereas \texttt{<foo://info.example.com?bernard>} has an empty path.

\subsection*{Query String}
The query component contains non-hierarchical data that, along with data in the path component, serves to identify a resource within the scope of the URI's scheme and naming authority.  The query component is indicated by the first question mark ("?") character and terminated by a number sign ("\#") character or by the end of the URI \autocite{berners2005uniform}.

A query is commonly found in the URL of dynamic pages. and is represented by a question mark followed by one or more parameters. The query directly follows the host name, path or port number. For example, this URL was generated by Google when doing a search for the word "query":

\begin{center}
  \url{https://www.google.com/search?q=query&rlz=1C5GCEM_enDE993DE993&oq=query&aqs=chrome..69i57j0i512l4j69i60l3.938j0j7&sourceid=chrome&ie=UTF-8}
\end{center}

\noindent This is the query part:

\begin{center}
  \url{?q=query&rlz=1C5GCEM_enDE993DE993&oq=query&aqs=chrome..69i57j0i512l4j69i60l3.938j0j7&sourceid=chrome&ie=UTF-8}
\end{center}

Because query components are frequently used to carry identifying information in the form of "key=value" pairs, and one frequently used value is a reference to another URI, it is sometimes preferable to avoid percent-encoding those characters for usability.

\subsection*{Anchor}
An anchor is a type of "bookmark" within the resource that instructs the browser to display the content located at that "bookmarked" location. For example, in an HTML document, the browser will scroll to the point where the anchor is defined; in a video or audio document, the browser will attempt to navigate to the time the anchor represents. It is important to note that the part following the \texttt{\#}, also known as the fragment identifier, is never sent to the server with the request.

\subsection{Search and Filter URL Parameters}
Search and filter URL parameters are parameters or query strings that add information to a specific URL. A search or filter parameter facilitates the search for a specific phrase or keyword within search engine results. They include what is requested while excluding irrelevant content. Aside from the functions mentioned above, the most common use cases for parameters are tracking, pagination, site search, sorting and filtering.

%Site Search
\section{Site Search}
Providing a search function that searches your Web pages is a design strategy that offers users a way to find content \autocite{w3c2016search}. Users can find content by searching for specific words or phrases without having to understand or navigate the site's structure. This can be a faster or easier way to find content on large sites. A great site search function is specific to the website and not only constantly indexes the site to ensure the most recent content is easily accessible, but it also guides users as they explore a website's content, assisting them in discovering content they may not have known they were interested in. The best site search products delight users by allowing them to quickly connect with the content they require while also collecting valuable data about the content and products that visitors are most interested in.


%Filters
\section{Filters and Facets}
\label{filters_and_facets}
The process of narrowing down a search based on predefined categories is known as filtering. These categories are frequently broad and based on a single dimension of the product. This allows user to quickly narrow down a large number of products to a more manageable set for further investigation.

Filters are broad categories defined by the business that do not change between searches, and they are frequently used behind the scenes. \emph{Nielsen Norman Group}\footnote{\emph{Nielsen Norman Group} is a leader in the user experience field, NN/g conducts groundbreaking research, trains and certifies UX practitioners, and provides UX consulting to clients. More information on \url{https://www.nngroup.com/}} defines filters as one such tool, which analyze a given set of content to exclude items that don't meet certain criteria \autocite{whitenton2014filters}. For example, an online clothing store might use "clothing type" as a filter, with four possible categories: shirts, pants, shoes, and accessories. When a website visitor clicks on "shirts" in the top navigation, the clothing type filter is applied, and the visitor sees only shirts on the results page.

Facets, also known as facet filters, enable users to filter results by selecting values along different dimensions or facets \autocite{qu2021study}. It is widely used in e-commerce search engines and digital libraries where documents have rich metadata. Faceted search is a more granular method of finding products and results in a specific, targeted way that broad, one-size-fits-all filters do not allow.

The distinction between filters and facets is essentially one of degree, but it is a significant one. Faceted navigation should ideally provide multiple filters, one for each different aspect of the content. Faceted navigation is thus more flexible and useful than systems that only provide one or two types of filters, particularly for extremely large content sets. Because faceted navigation describes many different dimensions of the content, it also provides a structure to assist users in understanding the content space and giving them ideas about what is available and how to search for it.

A well-designed user interface includes filters and facets. Contextual factors that vary depending on the item or category promote a user-friendly experience by directing the user down the shortest path to the best result. Although the faceted navigation system has obvious benefits for end users, it is significantly more expensive to create and maintain; more resources must be invested in designing the user interface, and metadata must be applied to both existing and future content for each facet. The additional power of faceted navigation raises interaction costs by providing users with more options to understand and manipulate. A simple filter is frequently easier to understand and use.


%Browser Extension
\section{Browser Extension}
Browser extensions or addons are third party programs, that can extend the functionality of browsers and improve users' browsing experience \autocite{some2019empoweb}. A browser extension, as opposed to a standard web page, is created specifically for a given browser and uses that browser's extension API. It was necessary to choose a browser as a result. There are frameworks that try to make it feasible to create an extension for several different browsers at once. Although the caliber of these frameworks was unclear, it was decided that the expense of potential problems and additional time spent debugging in many browsers outweighed the benefits.

%Chrome Extension Architecture
\subsection{Chrome Extension Architecture}
Extensions are built on web technologies such as HTML, JavaScript, and CSS. They run in a separate, sandboxed execution environment and interact with the Chrome browser \autocite{google2021what}. They also have access to the APIs that browsers provide for tasks like XMLHttpRequests and HTML5 features on web sites. The following files can be found in an extension:

\begin{itemize}
  \item A \texttt{manifest.json} file
  \item One or more HTML files
  \item Any other files such as CSS or JavaScript needed by the extension to run
\end{itemize}

The majority of extensions have a background page that contains their primary logic and state. They frequently also contain content scripts that can communicate with websites. Asynchronous message passing is used to communicate between the background page and the content scripts. Additionally, extensions can save data via localStorage and other HTML5 storage APIs.

\subsection{Manifest Files}
A \texttt{manifest.json} file is required for each extension. It includes crucial information about the extension, such its name, version, scripts used for its content, minimum Chrome version, and permissions. The content-scripts field was the most crucial one for this expansion. Each study and content-related webpage need its own content script. Each one was defined in the scripts column, which also mapped each one to the appropriate URLs.

\subsection{Content Scripts}
Content scripts are JavaScript files that are used on websites to add new functionality. They have full control to modify the entire web page because they can directly access the DOM of these web sites. The content script is injected into a tab when the web page is loaded, and runs in the same process space of the renderer of the web tab and can thus access its DOM objects. Injected content scripts in a tab can only communicate with the extension core via Chrome's IPC \autocite{liu2012chrome}.

\subsection{Service Worker}
The Chrome extension platform switches from background pages to service workers in Manifest V3. A service worker is a script that your browser runs in the background, distinct from a web page, opening the door to features that don't need a web page or user input \autocite{chrome2021service}. This technology allows native-like experiences over the open web, including push notifications, robust offline support, background synchronization, and "Add to Home Screen." Service providers drew some of their inspiration from the background pages in Chrome Extensions, but improvements were added for the web.

Service workers are specialized JavaScript assets that act as proxies between web browsers and web servers. They aim to improve reliability by providing offline access, as well as boost page performance \autocite{chrome2021service}. Websites are gradually improved by service workers through a lifetime akin to that of platform-specific programs.


%React
\section{React}
\label{react}
React is a product of Facebook's engineering team, which is a JavaScript framework for creating user interfaces \autocite{gackenheimer2015introducing}. Because of its simplicity and straightforward but efficient development process, React is quite well-liked in the developer communities. Interactive user interfaces are simpler to develop with React. It effectively updates by accurately drawing each state's view's constituent parts, and it updates the application's data \autocite{islam2017reactjs}. The core objective of React is to provide the best possible rendering performance. Its strength comes from the focus on individual components. Using reusable components, it is found to be easy development for developers to design rich UI's. React incorporates with View part from MVC model \autocite{maratkar2021re}. React implements One Way dataflow so that it gets easier than traditional data binding. React uses virtual DOM it offers not so complex programming with faster execution. It makes use of composition to create intricate user interfaces out of simple building blocks known as Components \autocite{david2020building}.

\subsection{Component and Props}
Components are self-contained and reusable pieces of code. They perform the same function as JavaScript functions, but they work independently and return React elements describing what should appear on the screen. They are classified as Class components or Function components. To describe what should be rendered, JSX, a combination of HTML and JavaScript, is used. See \autoref{jsx} for a more in-depth explanation. These functions accept arbitrary inputs, called \texttt{props}, and store property values inside a \texttt{state} object.

Immutable data supplied into a component during development is known as \texttt{props}, or properties. Because a component can function and seem differently depending on the properties supplied into it, \texttt{props} enable React components to be flexible and reusable.

Using props, data moves down the component tree in React. Callback functions are supplied as \texttt{props} so that a child component can communicate with its parent. Callback methods and other data must be passed down numerous layers in large React apps due to the component tree's depth. \emph{Prop-drilling}\footnote{\emph{Prop-drilling} is the unofficial term for passing data through several nested children components, in a bid to deliver this data to a deeply-nested component.} is a technique that results in tightly connected components and a less maintainable program. This is one of the reasons why complex React apps require architectural patterns.

\subsection{State and Lifecycle}
State allows an application to manage changing data. It is defined as an object in which key-value pairs specify various data that should be tracked in the application. The \texttt{state} is optional; components without a state are referred to as presentational components. Components with a state are referred to as stateful components.

Lifecycle methods are built-in functions that are called whenever a state or prop updates, a component renders, is destroyed, or both.

\subsection{Class-based components}
A class-based Component is created by extending the \texttt{React.Component} class. The state of a class-based component is updated using the method \texttt{setState()} and read by using \texttt{this.state} within the class. Using the \texttt{setState()} method makes the component re-render which is not the case when mutating the state directly. Class-based components include lifecycle methods that can be used to create more complex behavior. It also requires a render method to return JSX elements.


\subsection{Function components}
A pure function that takes \texttt{props} as input and outputs a JSX element is referred to as a function component. React Hooks are used to give the function component the same access to state and lifecycle methods as class-based components. In compared to class-based components, using function components with hooks might make React applications smaller and more manageable. There are a couple reasons why function component is preverable \autocite{phan2020react}:

\begin{itemize}
  \item Faster development, easier to read and test, debug and reusable; because function components do not have state and lifecycle-hook. Function component is a straightforward JavaScript function.
  \item Performance will be improved since function components are smaller and compiles more quickly than class components.
  \item There is no need to consider how to divide the component into a container and a standard UI component when utilizing a function component.
\end{itemize}

\subsection{React Hooks}
For more complex function components, React Hooks are utilized; they enables the use of Stateful Components features in Functional Components. Hooks are essentially functions that allows the management of the logic inside a component into reusable, isolated units and include React state and lifecycle functions without using classes. By default, \texttt{state} is absent from function component; however, the \texttt{useState} React hook can be used to keep state for the duration of the component. All hooks, including the \texttt{useState} one, are repeatable inside a single component.

Function components do not come with built-in lifecycle methods, but they can be added using the \texttt{useEffect} hook. By default, the \texttt{useEffect} hook will run a function for each time the component is re-rendered, but it may be modified to just run for specific modifications.

The \texttt{useContext} hook, which will be described in \autoref{contextApi}, is another React hook. In addition to built-in hooks, custom hooks can be made, allowing functionality to be reused throughout components.

\subsection{Virtual DOM}
For all components in the application, React generates a new View based on immutable states and props; a change to either a state or a prop causes the View to be re-rendered. The Views are now predictable and testable as a result. The user experience is negatively impacted by the time-consuming process of re-rendering views by swapping out the DOM for a new version, which also causes scrolling position and input information to be lost. Using a Virtual DOM, React provides a solution for this \autocite{david2020building}.

Views that need to be updated are redisplayed in an efficient manner without causing other DOM nodes to break by creating a new virtual DOM subtree whenever data in the application changes and comparing it to the prior subtree. React figures out how few DOM modifications are necessary to align the virtual and actual DOMs. The DOM manipulations in Javascript are then queued and carried out in batches to save time. Developers use JSX to specify how components should be rendered in the various states, while React handles manipulating the DOM to achieve the different states.

\subsection{Context API}
\label{contextApi}
The Context API is a built-in tool that allows data to be shared between React components without the need for prop-drilling. The \texttt{createContext} method in the React library is used to create a \texttt{Context} object, which can be used by several components in the component tree. Every \texttt{Context} object comes with a \texttt{Provider} React component that allows consuming components to subscribe to context changes \autocite{react2021context}. The closest matching \texttt{Provider} above it in the tree will be used to read the current context value when React renders a component that subscribes to this \texttt{Context} object. A \texttt{Provider} is used to add data to the \texttt{Context} object and make it accessible to its children components. The data for the \texttt{Context} is specified in the \texttt{Provider}, a component that has a single property named value and accepts variables, functions, or objects as values.

The \texttt{Context} data can be retrieved from any child component using a \texttt{Consumer} that is also available on the \texttt{Context} instance by enclosing children components inside the \texttt{Provider} component. A \texttt{Consumer} is a React component that subscribes to context changes \autocite{react2021context}. The application uses a variety of contexts for various purposes rather than being restricted to a single instance.

Context API's callback function inheritance allows a child component to change the state of a parent component. \texttt{Context} is used, according to the official documentation, to exchange information that is regarded as global for the tree of React components, such as whether a user is logged in, the application's theme, or the language preferences. Because they depend on information provided by context from another component, using context may reduce the reusability of components. The \texttt{useContext} hook functions as the \texttt{Consumer} and grants access to the data for a functional component encased in a \texttt{Context.Provider}.

\subsection{JSX}
\label{jsx}
A React extension called JSX makes it simple for web designers to change the DOM using straightforward HTML-style code. Additionally, as all current web browsers are supported by React JS, JSX is interoperable with any browser platform.

Most people find it helpful as a visual aid when working with UI inside the JavaScript code. It also allows React to show more useful error and warning messages \autocite{react2020introducing}. The advantages of JSX include the fact that it makes writing templates for users who are familiar with HTML simpler and faster. Performance improves when code is compiled into JavaScript \autocite{phan2020react}.

