\newpage
\chapter{Implementation}
After the design has been specified, the extension's implementation may begin. This section describes further explanation from \autoref{technologies_used} for the technology used. Because no backend implementation is required for the project, this section will only cover the front-end implementation.

\section{User Interface}
This section goes through some of the technical aspects of the user interface of the extension. The user interface was built with React. As described in \autoref{react}, React makes it easy to create interactive UIs. Using JSX makes it even simpler for web designers to change the browser's DOM using HTML. Furthermore, the user interface is developed in TypeScript rather than regular JavaScript to ensure type safety.

\subsection{Build Tool}
Nowadays, most front end projects use a build tool to assist in the development of web applications. The build tool for the user interface is Webpack 5.

\subsection{Component Library}
A component library is used in this project to speed up UI development. The rebass component library is used in this project. Rebass was chosen because it is lightweight and an excellent choice for prototype and UI development without the need to invest time in establishing a custom design system from the start.

\subsection{Code Style}
In this project, a code formatter (Prettier) and linter (ESLint) are used to ensure an uniform code style and conform with TypeScript best practices.

\section{File structure}
This section walks through the project's file structure, as shown in \autoref{directory_tree} \verb;.husky; is used to format code with prettier on git commit. Webpack generates the \verb;dist; folder. This folder contains the JavaScript files generated by TypeScript (such as background.js, contentScript.js, popup.html, etc.). It is clear from the folder structure that \verb;yarn; is the package manager and \verb;jest; is the testing library. The extension's essential files are inside \verb;src; and \verb;static;.

\begin{figure}[ht!]
  \dirtree{%
    .1 /.
    .2 .husky.
    .2 dist.
    .2 src.
    .3 background.
    .4 index.ts.
    .3 components.
    .4 BasicCard.
    .5 index.tsx.
    .5 subtitle.tsx.
    .5 title.tsx.
    .4 ....
    .3 content-script.
    .4 index.ts.
    .3 contexts.
    .4 parameter.tsx.
    .4 pathname.tsx.
    .4 url.tsx.
    .3 popup.
    .4 index.tsx.
    .4 popup-action.tsx.
    .4 popup-with-router.tsx.
    .4 popup.css.
    .4 popup.tsx.
    .3 spec.
    .3 types.
    .4 entry-type.ts.
    .3 utils.
    .4 storage.ts.
    .4 tabs.ts.
    .4 url.ts.
    .2 static.
    .3 icon.png.
    .3 manifest.json.
    .2 webpack.
    .3 webpack.common.js.
    .3 webpack.dev.js.
    .3 webpack.prod.js.
    .2 .gitignore.
    .2 jest.config.js.
    .2 package.json.
    .2 README.md.
    .2 tsconfig.json.
    .2 yarn.lock.
  }
  \caption{Directory Tree}
  \label{directory_tree}
\end{figure}

\section{Data storage}
This section goes over the data storage used for the project.


\begin{itemize}
  \item Implementation decisions, why use chrome.storage, why use react
  \item Introduce the simple software architecture
  \item Introduce the frontend react architecture
\end{itemize}

\section{Test}
% TODO:
To ensure that the \verb;chrome.storage; is tested, the unit tests must run within the context of a Chrome Extension. Furthermore, this allows for more thorough testing of the extension's individual components. Due to the increasing complexity, the use of a mocking framework for data simulation was omitted. For the tests, a configuration object is used instead. Because it allows for modular development and is widely used, Jest will be used as the test framework.
\begin{itemize}
  \item What kind of test? Unit testing, integration testing or functional testing?
  \item Short explanation on types of test
  \item Implementation of Test
  \item Which test libraries are being used?
  \item What are the assertions?
\end{itemize}

\section{Installation}
% TODO:
When a Chrome extension is installed, a manifest file is read, which acts as a contract between the extension and the browser. In addition to trivial data such as the extension's name, the runtime permissions are defined (\textit{permissions}). Furthermore, the functions that are to be triggered after events occur are registered with the help of so-called service workers (\textit{background}). Furthermore, an options page or configuration page (\textit{options\_page}) can be defined.
\begin{lstlisting}[caption={manifest.json}, language=json]
{
  "name": "Filtre Extension",
  "description": "Filtre Chrome Extension",
  "version": "1.0.0",
  "manifest_version": 3,
  "icons": {
    "16": "icon.png",
    "48": "icon.png",
    "128": "icon.png"
  },
  "action": {
    "default_popup": "popup.html",
    "default_title": "Filtre Extension",
    "default_icon": "icon.png"
  },
  "permissions": ["storage", "tabs", "unlimitedStorage"],
  "options_page": "options.html",
  "background": {
    "service_worker": "background.js"
  },
  "content_scripts": [
    {
      "matches": ["<all_urls>"],
      "js": ["contentScript.js"],
      "run_at": "document_idle"
    }
  ]
}
\end{lstlisting}

\section{Application}
% TODO:
\begin{lstlisting}[style=ES6, caption={background/index.ts}]
import { setStoredFilters } from '../utils/storage'

chrome.runtime.onInstalled.addListener(() => {
  setStoredFilters({})
})
\end{lstlisting}

\begin{lstlisting}[style=ES6, caption={TypeScript interface of a LocalStorage object in utils/storage.ts}]
export interface LocalStorage {
  filters?: Record<string, any>
  config?: Record<string, any>
}

export type LocalStorageKeys = keyof LocalStorage
\end{lstlisting}

\begin{lstlisting}[style=ES6, caption={utils/storage.ts}]
export const setStoredKey = (
  key: LocalStorageKeys,
  data: Record<string, any>
): Promise<void> => {
  const vals: LocalStorage = { [key]: data }
  return new Promise((resolve) => {
    chrome.storage.local.set(vals, resolve)
  })
}

export const setStoredFilters = (
  filters: Record<string, any>
): Promise<void> => {
  return setStoredKey('filters', filters)
}
\end{lstlisting}
