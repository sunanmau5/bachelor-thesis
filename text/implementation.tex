\newpage
\chapter{Implementation}
After the design has been specified, the extension's implementation may begin. This section describes further explanation from \autoref{technologies_used} for the technology used. Because no backend implementation is required for the project, this section will only cover the front-end implementation.

\section{User Interface}
This section goes through some of the technical aspects of the user interface of the extension. The user interface was built with React. As described in \autoref{react}, React makes it easy to create interactive UIs. Using JSX makes it even simpler for web designers to change the browser's DOM using HTML. Furthermore, the user interface is developed in TypeScript rather than regular JavaScript to ensure type safety.

\subsection{Build Tool}
Nowadays, most front end projects use a build tool to assist in the development of web applications. The build tool for the user interface is Webpack 5\footnote{\emph{Webpack} is a bundler for static modules that is used in modern applications written in JavaScript. Webpack version 5 includes faster builds with persistent caching, smaller bundler size, Module Federation, etc. More information on \url{https://webpack.js.org/blog/2020-10-10-webpack-5-release/}}.

\subsection{Component Library}
A component library is used in this project to speed up UI development. The rebass component library is used in this project. Rebass\footnote{\emph{Rebass} is a simple React UI component library that allows you to create primitive UI components using the Styled System library. Rebass homepage: \url{https://rebassjs.org/}} was chosen because it is lightweight and an excellent choice for prototype and UI development without the need to invest time in establishing a custom design system from the start.

\subsection{Code Style}
In this project, a code formatter (Prettier) and linter (ESLint) are used to ensure a uniform code style and conform with TypeScript best practices.

\subsection{Utility Libraries}
The large JavaScript bundle is one of the most prevalent performance problems in front-end development. Watching the loading spinner and using complicated, slow applications are situations that should be avoided. The utility libraries, which are sets of functions for typical tasks like formatting dates and looking for unique items in arrays, have a big impact on the bundle size. However, the extension's development can go much more quickly with the aid of utility libraries. The following utility libraries were used for the extension:

\begin{itemize}
  \item Lodash\footnote{\emph{Lodash}. GitHub repository \url{https://github.com/lodash/lodash}}: A modern utility library that performs typical functional programming tasks.
  \item date-fns\footnote{\emph{date-fns}. GitHub repository \url{https://github.com/date-fns/date-fns}}: A modern date utility library for manipulating dates and time, which are typically difficult for developers to handle.
  \item React Feather\footnote{\emph{React Feather}. GitHub repository \url{https://github.com/feathericons/react-feather}}: A set of icons for React that are used in the scope of this project.
\end{itemize}

\section{File structure}
This section walks through the project's file structure, as shown in \autoref{directory_tree} \texttt{.husky} is used to format code with prettier on git commit. Webpack generates the \texttt{dist} folder. This folder contains the JavaScript files generated by TypeScript (such as \texttt{background.js}, \texttt{contentScript.js}, \texttt{popup.html}, etc.). From the folder structure it is conceivable that \texttt{yarn} is the package manager and \texttt{jest} is the testing library. The extension's essential files are inside \texttt{src} and \texttt{static}. The \texttt{options} directory is in charge for the View of the options page, whereas \texttt{popup} is responsible for the extension's pop-up. All of the React components used in this project, like all other React projects, are saved in the \texttt{components} directory. All necessary components are imported from the \texttt{components} directory into the extension's pop-up and options page. Additionally, all of the React Hooks used in this project are kept in the \texttt{hooks} directory. The \texttt{hoc} folder, houses the files that make up the Higher-Order Components (HOC), which are an advanced component pattern in React. This pattern is employed for this project's component styling and conditional rendering.

\begin{figure}[H]
  \dirtree{%
    .1 /.
    .2 .husky.
    .2 dist.
    .2 src.
    .3 background.
    .3 components.
    .3 constants.
    .3 content-script.
    .3 contexts.
    .4 parameter.tsx.
    .4 pathname.tsx.
    .4 url.tsx.
    .3 hoc.
    .3 hooks.
    .3 options.
    .4 index.css.
    .4 index.tsx.
    .4 options.tsx.
    .3 popup.
    .4 index.css.
    .4 index.tsx.
    .4 popup-with-router.tsx.
    .4 popup.tsx.
    .3 spec.
    .3 types.
    .3 utils.
    .4 storage.ts.
    .4 tabs.ts.
    .4 url.ts.
    .2 static.
    .3 icons.
    .3 manifest.json.
    .2 webpack.
    .2 .gitignore.
    .2 jest.config.js.
    .2 package.json.
    .2 README.md.
    .2 tsconfig.json.
    .2 yarn.lock.
  }
  \caption{Directory Tree}
  \label{directory_tree}
\end{figure}

\section{Installation}
When a Chrome extension is installed, a manifest file is read, which acts as a contract between the extension and the browser. In addition to trivial data such as the extension's name, description and version, the runtime permissions are defined (\texttt{permissions}). Furthermore, the functions that are to be triggered after events occur are registered with the help of so-called service workers (\texttt{background}). Furthermore, an options page or configuration page (\verb;options_page;) can be defined. The version of the manifest file is determined by \verb;manifest_version;, which is currently the most recent and recommended version. The field \texttt{action} allows the user to customize the appearance and behavior of the buttons that appear on the Chrome toolbar. In this case when the button with the icon \texttt{icons/icon-filtre-16.png} is clicked Chrome will load the \texttt{popup.html} file. The \verb;content_scripts; field in the manifest is used to register scripts that are statically declared and contains the following variables:

\begin{itemize}
  \item \texttt{matches}: Specifies which pages will receive the script injection. The special pattern that is used \verb;<all_urls>; matches any URL that starts with a permitted scheme\footnote{\texttt{http}, \texttt{https}, \texttt{urn}, \texttt{file}, or \texttt{ftp}, and that can contain "*" characters are all permitted schemes of a URL}.
  \item \texttt{js}: An array of JavaScript files to be embedded in relevant web pages. The elements of this array are injected in the order in which they appear here.
  \item \verb;run_at;: Controls at which point in time the JavaScript files are injected into the web page.
\end{itemize}

By setting the \verb;run_at; field to be \verb;document_idle;, the browser chooses a time to inject scripts between \verb;document_end; and immediately after the \emph{window.onload}\footnote{\emph{window.onload} event is triggered when the entire page, including all dependent resources such as stylesheets and images, has loaded. More information on \url{https://developer.mozilla.org/en-US/docs/Web/API/Window/load_event}} event fires. The exact moment of injection depends on how complex the document is and how long it is taking to load, and is optimized for page load speed \autocite{chrome2021runtime}.

\begin{lstlisting}[language=json, caption={Manifest File (JSON)}, label={lst:manifest}]
{
  "name": "Filtre",
  "description": "A filtering assistant for Chrome",
  "version": "0.0.1",
  "manifest_version": 3,
  "icons": {
    "16": "icons/icon-filtre-16.png",
    "48": "icons/icon-filtre-48.png",
    "128": "icons/icon-filtre-128.png"
  },
  "action": {
    "default_popup": "popup.html",
    "default_title": "Filtre",
    "default_icon": "icons/icon-filtre-16.png"
  },
  "permissions": ["storage", "tabs", "unlimitedStorage"],
  "options_page": "options.html",
  "background": {
    "service_worker": "background.js"
  },
  "content_scripts": [
    {
      "matches": ["<all_urls>"],
      "js": ["contentScript.js"],
      "run_at": "document_idle"
    }
  ]
}
\end{lstlisting}

This function (\autoref{lst:background}) is invoked upon extension installation, extension update, and Chrome update. An empty object is set as the initial filters and a default config object is set as the initial configuration.

\begin{lstlisting}[style=ES6, caption={On install functions (TypeScript)}, label={lst:background}]
  import { setStoredConfig, setStoredFilters } from '../utils/storage'

  chrome.runtime.onInstalled.addListener(() => {
    setStoredFilters({})
    setStoredConfig({
      excludedParameters: [],
      topFiltersCount: DEFAULT_TOP_FILTERS_COUNT // 3
    })
  })
\end{lstlisting}

\begin{lstlisting}[style=ES6, caption={Helper functions for Chrome Storage API (TypeScript)}]
export const setStoredKey = (
  key: LocalStorageKeys,
  data: Record<string, any>
): Promise<void> => {
  const vals: LocalStorage = { [key]: data }
  return new Promise((resolve) => {
    chrome.storage.local.set(vals, resolve)
  })
}

export const setStoredFilters = (
  filters: Record<string, any>
): Promise<void> => {
  return setStoredKey('filters', filters)
}
\end{lstlisting}

\begin{lstlisting}[style=ES6, caption={TypeScript interface of a LocalStorage object (TypeScript)}]
export interface LocalStorage {
  filters?: Record<string, any>
  config?: Record<string, any>
}

export type LocalStorageKeys = keyof LocalStorage
\end{lstlisting}

\section{Realization}
While the implementation's primary focus was on storing records, a number of issues arose during the process of integrating the source code into a Google Chrome extension that required attention. When and how the URL should be stored were the main concerns. This section explores the solutions to these problems.

\subsection*{Storing Point in Time}
The first question can be addressed by \autoref{lst:manifest}, on the \verb;content_scripts; field. Since the \verb;run_at; field is set to \verb;document_idle;, the URL is stored immediately after the whole page has loaded. That is, everytime a website is viewed or refreshed, the record is always saved, even if the user navigates away from the tab while the page loads.

This solution works, however, only if the user do a full page refresh. Client-side routing is used by the majority of front-end applications today. Due to the rise in popularity of single-page applications, a greater number of developers now consider client-side routing when building single-page applications (SPAs). When a user clicks on an internal link within the SPA, the URL bar should change to indicate that the page is being updated without requiring a complete page refresh.

Therefore, we moved the upserting filter function from the content scripts to the service workers. Whenever a tab is updated, the upsert filter function is invoked by the services workers.

\subsection*{TypeScript type of data}
To answer the second question, the record that we want to store needs to be uniform. To provide a clear record structure, a TypeScript type is created.

\begin{lstlisting}[style=es6, caption={TypeScript type of a record entry (TypeScript)}]
export type ParameterType = {
  uuid: string
  createdAt: number
  version: string
  paramKey: string
  paramValue: string
  count: number
  lastUpdatedAt: number
}

export type Parameters = ParameterType[]

export type PathType = {
  name: string
  subpaths: PathType[]
  parameters: Parameters
}

export type Paths = PathType[]

export type Entry = {
  [host: string]: Paths
}

export type GeneralState = 'loading' | 'ready' | 'error'

export type ITopFilter = Pick<
  IParameter,
  'count' | 'uuid' | 'paramKey' | 'paramValue'
> & { path: string }

export type ITopFilters = ITopFilter[]
\end{lstlisting}

\subsection*{Filters in URLs}
As mentioned in \autoref{url_anatomy}, a URL consists of various components, some of which are hostname, path and query string. The topics, filters and facets, were also discussed in \autoref{filters_and_facets}. When adding persistent filters to a website, these definitions play a significant role.

Due to the hierarchical nature of a URL's path, traditional filters are typically positioned there. Facets typically utilize the query portion of a URL, as they are not hierarchical. Hierarchical classification refers to the process of classifying objects using a single hierarchical taxonomy. Faceted classification may employ hierarchy in one or more of its facets, but also permits the use of multiple taxonomies to classify objects. As seen in the preceding examples, the multiple taxonomies provided by facets are unsuitable for inclusion in the URL's path segment. Returning to the use of non-standard URL encoding, as stated in \autoref{url_anatomy} of the Path definition:

\begin{displayquote}
  The path component contains data, usually organized in hierarchical form, that, along with data in the non-hierarchical query component, serves to identify a resource ...
\end{displayquote}

\noindent and \autoref{url_anatomy} under Query String continues:

\begin{displayquote}
  The query component contains non-hierarchical data
\end{displayquote}

\noindent This indicates that facets should not appear in path segments, but rather as query parameters.

\begin{figure}[H]
  \includegraphics[width=\textwidth]{assets/screenshot_nike_website.png}
  \caption{Nike's Mens Black Sneakers URL full-path}
  \label{fig:nikeMensBlackSneakersUrl}
\end{figure}

In practice, however, not all websites adhere to these guidelines. A good comparison would be how Nike and Lacoste filter their products on their respective websites (See \autoref{fig:nikeMensBlackSneakersUrl} and \autoref{fig:lacosteMensBlackSneakersUrl}). In both of these examples, the user is looking for black sneakers on their respective websites. The figures show that both have different ways of displaying the URL. Nike includes the filters and facets in the URL path, as well as a hash string at the end. Lacoste, on the other hand, stores the classic filter in the URL path and the facets as URL queries, which is the preferred method of utilizing the URL. Lacoste stores the query parameter's value in a JSON format. If the URL is decoded twice, the output would be: \verb;?filters={"searchColorID":"Schwarz"}';.

\begin{figure}[H]
  \includegraphics[width=\textwidth]{assets/screenshot_lacoste_website.png}
  \caption{Lacoste's Mens Black Sneakers URL full-path}
  \label{fig:lacosteMensBlackSneakersUrl}
\end{figure}

The solution to this issue would be to store both the query parameters and the path component of the URL. These properties ought to be accessible through the same hostname. However, this solution raises an additional problem: how to transform the URL so that it can be stored as JSON.

\subsection*{Converting URL to JSON Object}
The URL must be saved as a JSON object in order to count the number of times each query parameter is entered for each host. Here is an example of storing a simple URL with a single path and a query parameter:

\noindent\begin{center}
  \url{https://app.marta.de/caregivers?caregiver.germanVerbalProficiency=one,two}
\end{center}

\begin{lstlisting}[language=json, caption={A record example from app.marta.de (JSON)}]
{
  "app.marta.de": [
    {
      "name": "/caregivers",
      "parameters": [
        {
          "count": 1,
          "createdAt": 1660224894790,
          "lastUpdatedAt": 1660224894790,
          "paramKey": "caregiver.germanVerbalProficiency",
          "paramValue": "one,two",
          "uuid": "8006a4a5-482e-4282-940f-569a54fd29ce",
          "version": "0.1.0"
        }
      ],
      "subpaths": []
    }
  ]
}
\end{lstlisting}

Converting such a simple URL to a JSON object is a straightforward process. A problem arises when converting more complex URLs on a faceted navigation system, as depicted in \autoref{fig:lacosteMensBlackSneakersUrl} To store nested URL paths in our data structure, URLs are traversed in a manner similar to directories. In order to convert URL pathname to a JSON object, a recursive helper function has been implemented, as shown in \autoref{lst:recursiveUpsertFunc}. Therefore, the previously mentioned URL can be saved as follows:

\begin{lstlisting}[language=json, caption={Record with long pathname (JSON)}, label={lst:recordLongPathname}]
{
  "www.lacoste.com": [
		{
			"name": "/de",
			"parameters": [],
			"subpaths": [
				{
					"name": "/lacoste",
					"parameters": [],
					"subpaths": [
						{
							"name": "/herren",
							"parameters": [],
							"subpaths": [
								{
									"name": "/schuhe",
									"parameters": [],
									"subpaths": [
										{
											"name": "/sneakers",
											"parameters": [],
											"subpaths": [
												{
													"name": "/",
													"parameters": [
														{
															"count": 1,
															"createdAt": 1660552042754,
															"lastUpdatedAt": 1660552042754,
															"paramKey": "filters",
															"paramValue": "%7B%22searchColorID%22:%22Schwarz%22%7D",
															"uuid": "8a737280-8feb-4968-a97f-222424eb6c95",
															"version": "0.1.0"
														}
													],
													"subpaths": []
												}
											]
										}
									]
								}
							]
						}
					]
				}
			]
		}
	],
}
\end{lstlisting}

Due to the scalability of the data structure depicted in \autoref{lst:recordLongPathname}, visiting another pathname from the same host is not a problem, as shown in \autoref{lst:recordDifferentPathnames}. This structure permits subpaths to contain additional subpaths and queries. Each subpath can contain additional subpaths and queries with this structure. If a user visits the URL \url{https://www.lacoste.com/de/lacoste/herren/schuhe?filters=...}, the parameter values are added to the array of parameters under the subpath \texttt{/schuhe}.

\begin{lstlisting}[language=json, caption={Record with different pathnames (JSON)}, label={lst:recordDifferentPathnames}]
...
  {
    "name": "/schuhe",
    "parameters": [],
    "subpaths": [
      {
        "name": "/sneakers",
        "parameters": [],
        "subpaths": [
          {
            "name": "/",
            "parameters": [
              {
                "count": 2,
                "createdAt": 1660552137705,
                "lastUpdatedAt": 1660552137705,
                "paramKey": "filters",
                "paramValue": "%7B%22searchColorID%22:%22Schwarz%22%7D",
                "uuid": "5882c1bf-92e8-4e3f-9454-1b6f1acd6dc7",
                "version": "0.1.0"
              }
            ],
            "subpaths": []
          }
        ]
      },
      {
        "name": "/outdoor",
        "parameters": [],
        "subpaths": [
          {
            "name": "/",
            "parameters": [
              {
                "count": 1,
                "createdAt": 1660552464135,
                "lastUpdatedAt": 1660552464135,
                "paramKey": "filters",
                "paramValue": "%7B%22searchColorID%22:%22Schwarz%22%7D",
                "uuid": "31b25e02-9631-4bc1-acda-740c7fb58343",
                "version": "0.1.0"
              }
            ],
            "subpaths": []
          }
        ]
      }
    ]
  }
...
\end{lstlisting}

\begin{lstlisting}[style=ES6, caption={Recursive pathname to JSON function (TypeScript)}, label={lst:recursiveUpsertFunc}]
const recursiveUpsertFunc = (
  filters: PathType[],
  paths: string[],
  parameters: URLSearchParams
) => {
  const element = paths.shift()
  if (typeof element === 'undefined' || element === null) return
  const pathIndex = filters.findIndex((f) => f.name === element)

  if (pathIndex > -1) {
    if (paths.length > 0) {
      recursiveUpsertFunc(
        filters[pathIndex].subpaths,
        paths,
        parameters
      )
    } else {
      filters[pathIndex].parameters = upsertParams(
        filters[pathIndex].parameters,
        parameters
      )
    }
  } else {
    if (paths.length > 0) {
      const newLength = filters.push({
        name: element,
        parameters: [],
        subpaths: []
      })
      recursiveUpsertFunc(
        filters[newLength - 1].subpaths,
        paths,
        parameters
      )
    } else {
      const newParameters = upsertParams([], parameters)
      filters.push({
        name: element,
        parameters: newParameters,
        subpaths: []
      })
    }
  }
}
\end{lstlisting}

\subsection*{Retrieving the Top Filters}
While converting the URL into a JSON object is a formidable task, obtaining the top most used filters is more challenging. It is necessary to use yet another recursive helper function because it is unclear how deeply the JSON object is nested. This task cannot be resolved by using a regular loop function. Before starting to write the function, as depicted in \autoref{lst:recursiveTopFiltersFunc}, the procedures needed to solve the issue are defined.

An array must first be initialized, and it will contain the top most used parameters. The options page of the extension allows users to change the length of this array. The second step entails iterating through each of the root paths that are accessible. Third, the parameters array for each path must be looped through and then the number of times each parameter is entered needs to be compared against existing values inside the top parameters array. The process is then repeated until every subpaths and parameters array is iterated.

\begin{lstlisting}[style=ES6, caption={Recursive function to fetch the top filters (TypeScript)}, label={lst:recursiveTopFiltersFunc}]
const recursiveTopFilterFunc = (
  topFilters: ITopFilters,
  paths: IPaths,
  pathname?: string
) => {
  for (const { name, parameters, subpaths } of paths) {
    let subpathname = pathname ? `${pathname}${name}` : name

    // Find out the maximum count of the parameters
    for (const param of parameters) {
      const { uuid, count, paramKey, paramValue } = param
      if (
        // Continue if current `count` is less than
        // the minimum value of the `topFilters` array
        (topFilters.length === topFiltersCount &&
          count < topFilters[topFiltersCount - 1].count) ||
        // Continue if user excludes current `paramKey`
        // in the options page
        excludedParameters.includes(paramKey)
      ) {
        continue
      }
      topFilters.push({
        path: subpathname,
        uuid,
        count,
        paramKey,
        paramValue
      })

      // Always sort the parameter count in a descending
      // order
      topFilters.sort((a, b) => b.count - a.count)

      // Remove excess `count` if `topFilters` length
      // exceeds the `topFiltersCount`
      if (topFilters.length > topFiltersCount) {
        topFilters.pop()
      }
    }
    recursiveTopFilterFunc(topFilters, subpaths, subpathname)
  }
}
\end{lstlisting}
